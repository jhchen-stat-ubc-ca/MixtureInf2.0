#' pmle.exp
#'
#' 
#' @description This function computes the penalized MLE, given iid observations under the finite exponential mixture model.
#' @param x The input data that can be either a vector or a matrix with the 1st column being the observed values
#' and the 2nd column being the corresponding frequency.
#' @param m0 The order under null hypothesis.
#' @param lambda The size of the penalized function of the mixing distribution, default value: lambda = 1.
#' @param init.val NULL or a 2 X m0 matrix with rows made of the mixing probabilities and component means.
#' @param n.init The initial values generated by the computer.
#' @param n.iter The number of EM iterations for each initial values. The one gained most in likelihood will be iterative further. 
#' @param max.iter The maximum amount of iterations allowed. Set to 5000.
#' @param tol A tolerance value, EM concludes when the increment in p-likelihood is below tol.
#' @param rformat The format of the output, rformat=T means the format is determined by R.
#'		rformat=F means the format is determined by our default setting. When the output is
#'		larger than 0.001, it is determined by round(output,3); When the output is less than 0.001,
#'		it is determined by signif(output,3).
#'
#' @return It returns the PMLE or MLE of the parameters with order = m0 (mixing proportions and component
#' parameters), log-likelihood value at the PMLE or MLE and the penalized log-likelihood value at the PMLE.
#' @author Shaoting Li, Jiahua Chen and Pengfei Li
#'
#' @examples n = 4000
#' mu = c(3, 9, 18)
#' alpha = c(.5, .3, .2)
#' x = rmix.exp(n, alpha, mu) 
#' pmle.exp(x, 3)
pmle.exp <- function(x, m0, lambda = 1, init.val = NULL,
                     n.init = 10, n.iter=50, max.iter = 5000, tol=1e-8, rformat = F)
{
  if(m0==1) stop("You do not need this function for MLE")
  
  if(is.data.frame(x)) stop("data format must a vector or matrix")
  
  if (is.vector(x)) xx = x   ## plain vector case
  
  if (is.matrix(x)) {
    xx=c()
    for (i in 1:nrow(x)) xx=c(xx, rep(x[i,1],x[i,2]))
  }       ## it translates the frequency into a plain vector.
  
  
  out = pmle.exp.sub(xx, m0, lambda, init.val, n.init, 
                     n.iter, max.iter, tol)
  
  alpha=out$alpha
  theta=out$theta
  loglik=out$loglik
  ploglik=out$ploglik
  
  if (!rformat) {
    alpha=rousignif(alpha)
    theta=rousignif(theta)
    loglik=rousignif(loglik)
    ploglik=rousignif(ploglik)
  }
  
  list('PMLE of mixing proportions:'= alpha,
       'PMLE of component parameters:'= theta,
       'log-likelihood:'= loglik,
       'Penalized log-likelihood:'= ploglik)
}